import{R as k}from"./index-BBZVV66L.js";const E=t=>{let s;const e=new Set,o=(l,h)=>{const f=typeof l=="function"?l(s):l;if(!Object.is(f,s)){const c=s;s=h??(typeof f!="object"||f===null)?f:Object.assign({},s,f),e.forEach(S=>S(s,c))}},a=()=>s,d={setState:o,getState:a,getInitialState:()=>n,subscribe:l=>(e.add(l),()=>e.delete(l))},n=s=t(o,a,d);return d},H=t=>t?E(t):E,G=t=>t;function N(t,s=G){const e=k.useSyncExternalStore(t.subscribe,()=>s(t.getState()),()=>s(t.getInitialState()));return k.useDebugValue(e),e}const R=t=>{const s=H(t),e=o=>N(s,o);return Object.assign(e,s),e},O=t=>t?R(t):R;function T(t,s){let e;try{e=t()}catch{return}return{getItem:a=>{var r;const u=n=>n===null?null:JSON.parse(n,void 0),d=(r=e.getItem(a))!=null?r:null;return d instanceof Promise?d.then(u):u(d)},setItem:(a,r)=>e.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>e.removeItem(a)}}const p=t=>s=>{try{const e=t(s);return e instanceof Promise?e:{then(o){return p(o)(e)},catch(o){return this}}}catch(e){return{then(o){return this},catch(o){return p(o)(e)}}}},F=(t,s)=>(e,o,a)=>{let r={storage:T(()=>localStorage),partialize:i=>i,version:0,merge:(i,y)=>({...y,...i}),...s},u=!1;const d=new Set,n=new Set;let l=r.storage;if(!l)return t((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),e(...i)},o,a);const h=()=>{const i=r.partialize({...o()});return l.setItem(r.name,{state:i,version:r.version})},f=a.setState;a.setState=(i,y)=>{f(i,y),h()};const c=t((...i)=>{e(...i),h()},o,a);a.getInitialState=()=>c;let S;const x=()=>{var i,y;if(!l)return;u=!1,d.forEach(m=>{var g;return m((g=o())!=null?g:c)});const v=((y=r.onRehydrateStorage)==null?void 0:y.call(r,(i=o())!=null?i:c))||void 0;return p(l.getItem.bind(l))(r.name).then(m=>{if(m)if(typeof m.version=="number"&&m.version!==r.version){if(r.migrate){const g=r.migrate(m.state,m.version);return g instanceof Promise?g.then(I=>[!0,I]):[!0,g]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,m.state];return[!1,void 0]}).then(m=>{var g;const[I,D]=m;if(S=r.merge(D,(g=o())!=null?g:c),e(S,!0),I)return h()}).then(()=>{v==null||v(S,void 0),S=o(),u=!0,n.forEach(m=>m(S))}).catch(m=>{v==null||v(void 0,m)})};return a.persist={setOptions:i=>{r={...r,...i},i.storage&&(l=i.storage)},clearStorage:()=>{l==null||l.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>x(),hasHydrated:()=>u,onHydrate:i=>(d.add(i),()=>{d.delete(i)}),onFinishHydration:i=>(n.add(i),()=>{n.delete(i)})},r.skipHydration||x(),S||c},w=F,P={EASY:{speed:150,obstacleCount:0},MEDIUM:{speed:120,obstacleCount:5},HARD:{speed:90,obstacleCount:10},EXTREME:{speed:70,obstacleCount:15}},b=(t,s,e=[])=>{let o;do o={x:Math.floor(Math.random()*(s-t))+t,y:Math.floor(Math.random()*(s-t))+t};while(e.some(a=>a.x===o.x&&a.y===o.y));return o},M=O()(w((t,s)=>({snake:[{x:5,y:5,animX:5,animY:5}],food:{x:10,y:10},obstacles:[],direction:"RIGHT",nextDirection:"RIGHT",score:0,gameStatus:"IDLE",animationInProgress:!1,difficulty:"MEDIUM",boardSize:20,theme:"CLASSIC",soundEnabled:!0,highScores:[],setDirection:e=>{const{nextDirection:o}=s();e==="UP"&&o==="DOWN"||e==="DOWN"&&o==="UP"||e==="LEFT"&&o==="RIGHT"||e==="RIGHT"&&o==="LEFT"||t({nextDirection:e})},startGame:()=>{const{difficulty:e,boardSize:o}=s(),a=P[e].obstacleCount,r=[];if(a>0){const u=[{x:5,y:5,animX:5,animY:5}],d=b(1,o-1,u);for(let n=0;n<a;n++)r.push(b(1,o-1,[...u,d,...r]))}t({snake:[{x:5,y:5,animX:5,animY:5}],food:b(1,o-1,[{x:5,y:5}]),obstacles:r,direction:"RIGHT",nextDirection:"RIGHT",score:0,gameStatus:"RUNNING",animationInProgress:!1})},pauseGame:()=>t({gameStatus:"PAUSED"}),resumeGame:()=>t({gameStatus:"RUNNING"}),resetGame:()=>t({snake:[{x:5,y:5,animX:5,animY:5}],food:{x:10,y:10},obstacles:[],direction:"RIGHT",nextDirection:"RIGHT",score:0,gameStatus:"IDLE",animationInProgress:!1}),moveSnake:()=>{const{snake:e,nextDirection:o,food:a,obstacles:r,boardSize:u}=s();console.log("Snake at start of moveSnake:",JSON.stringify(e,null,2));const d=o,n={...e[0]},l=n.x,h=n.y;switch(d){case"UP":n.y-=1;break;case"DOWN":n.y+=1;break;case"LEFT":n.x-=1;break;case"RIGHT":n.x+=1;break}if(n.prevX=l,n.prevY=h,n.animX=l,n.animY=h,n.x<0||n.y<0||n.x>=u||n.y>=u){s().gameOver();return}if(e.some(c=>c.x===n.x&&c.y===n.y)){s().gameOver();return}if(r.some(c=>c.x===n.x&&c.y===n.y)){s().gameOver();return}const f=[n,...e];n.x===a.x&&n.y===a.y?(console.log("Food eaten! Snake before:",[...e]),s().eatFood(),console.log("After eatFood. New head:",n,"Snake length:",f.length)):f.pop(),f.forEach((c,S)=>{S>0&&(c.prevX=c.x,c.prevY=c.y,c.animX=c.x,c.animY=c.y)}),console.log("moveSnake completed. New snake:",[...f]),t({snake:f,direction:d,animationInProgress:!0}),console.log("Updated snake AFTER set:",s().snake)},eatFood:()=>{const{snake:e,obstacles:o,boardSize:a,score:r}=s();console.log("eatFood called. Current snake:",[...e]);const u=b(0,a,[...e,...o]);console.log("New food generated at:",u),t({food:u,score:r+10}),console.log("eatFood completed. Score:",r+10)},gameOver:()=>{t({gameStatus:"GAME_OVER"})},addHighScore:e=>{const{score:o,difficulty:a,highScores:r}=s(),u={initials:e,score:o,difficulty:a,date:new Date().toISOString()},d=[...r,u].sort((n,l)=>l.score-n.score).slice(0,10);t({highScores:d})},setDifficulty:e=>t({difficulty:e}),setBoardSize:e=>t({boardSize:e}),setTheme:e=>t({theme:e}),toggleSound:()=>t(e=>({soundEnabled:!e.soundEnabled}))}),{name:"snake-game-storage",partialize:t=>({highScores:t.highScores,difficulty:t.difficulty,boardSize:t.boardSize,theme:t.theme,soundEnabled:t.soundEnabled})}));export{M as u};
